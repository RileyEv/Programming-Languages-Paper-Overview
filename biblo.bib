@inproceedings{Fokkinga1989TuplingAM,
  title =        {Tupling and Mutumorphisms},
  author =       {M. Fokkinga},
  year =         1989
}

@article{datatypesalacarte,
  title =        {Data types à la carte},
  volume =       18,
  DOI =          {10.1017/S0956796808006758},
  number =       4,
  journal =      {Journal of Functional Programming},
  publisher =    {Cambridge University Press},
  author =       {Swierstra, Wouter},
  year =         2008,
  pages =        {423–436}
}

@inproceedings{embedding,
  title =        "Folding Domain-Specific Languages: Deep and Shallow
                  Embeddings",
  author =       "Jeremy Gibbons and Nicolas Wu",
  year =         2014,
  booktitle =    "International Conference on Functional Programming",
  month =        "September",
  pages =        "339-347",
  url =
                  "http://www.cs.ox.ac.uk/jeremy.gibbons/publications/embedding.pdf",
  doi =          "10.1145/2628136.2628138",
}

@article{mcbride2011functional,
  title =        {Functional pearl: Kleisli arrows of outrageous fortune},
  author =       {McBride, Conor},
  journal =      {Journal of Functional Programming (accepted for publication)},
  year =         2011
}

@article{parsley,
  author =       {Willis, Jamie and Wu, Nicolas and Pickering, Matthew},
  title =        {Staged Selective Parser Combinators},
  year =         2020,
  issue_date =   {August 2020},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       4,
  number =       {ICFP},
  url =          {https://doi.org/10.1145/3409002},
  doi =          {10.1145/3409002},
  abstract =     {Parser combinators are a middle ground between the fine
                  control of hand-rolled parsers and the high-level almost
                  grammar-like appearance of parsers created via parser
                  generators. They also promote a cleaner, compositional design
                  for parsers. Historically, however, they cannot match the
                  performance of their counterparts. This paper describes how to
                  compile parser combinators into parsers of hand-written
                  quality. This is done by leveraging the static information
                  present in the grammar by representing it as a tree. However,
                  in order to exploit this information, it will be necessary to
                  drop support for monadic computation since this generates
                  dynamic structure. Selective functors can help recover lost
                  functionality in the absence of monads, and the parser tree
                  can be partially evaluated with staging. This is implemented
                  in a library called Parsley.},
  journal =      {Proc. ACM Program. Lang.},
  month =        aug,
  articleno =    120,
  numpages =     30,
  keywords =     {parsers, meta-programming, combinators}
}

@InProceedings{scans,
  author =       "Hinze, Ralf",
  editor =       "Kozen, Dexter",
  title =        "An Algebra of Scans",
  booktitle =    "Mathematics of Program Construction",
  year =         2004,
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "186--210",
  abstract =     "A parallel prefix circuit takes n inputs x1, x2, ..., xnand
                  produces the n outputs x1, x1 ∘ x2, ...,
                  x1{\thinspace}∘{\thinspace}x2{\thinspace}∘{\thinspace}⋯{\thinspace}∘{\thinspace}xn,
                  where'∘' is an arbitrary associative binary operation.
                  Parallel prefix circuits and their counterparts in software,
                  parallel prefix computations or scans, have numerous
                  applications ranging from fast integer addition over parallel
                  sorting to convex hull problems. A parallel prefix circuit can
                  be implemented in a variety of ways taking into account
                  constraints on size, depth, or fan-out. Traditionally,
                  implementations are either defined graphically or by
                  enumerating the underlying graph. Both approaches have their
                  pros and cons. A figure if well drawn conveys the possibly
                  recursive structure of the scan but it is not amenable to
                  formal manipulation. A description in form of a graph while
                  rigorous obscures the structure of a scan and is equally hard
                  to manipulate. In this paper we show that parallel prefix
                  circuits enjoy a very pleasant algebra. Using only two basic
                  building blocks and four combinators all standard designs can
                  be described succinctly and rigorously. The rules of the
                  algebra allow us to prove the circuits correct and to derive
                  circuit designs in a systematic manner.",
  isbn =         "978-3-540-27764-4"
}

@misc{wuYoda,
  title =        {Yoda: A simple combinator library},
  url =          {https://github.com/zenzike/yoda},
  journal =      {GitHub},
  author =       {Wu, Nicolas},
  year =         2018
}
