%TC:envir hscode [] ignore
\documentclass[a4paper, twocolumn, 10pt]{extarticle}

% Tiny borders should be default
\usepackage[a4paper, total={7in, 10.25in}]{geometry}

\setlength {\marginparwidth }{2cm}
\usepackage{todonotes}
% Font shit
%\usepackage{fontspec}
%\usepackage{xunicode}
%\usepackage{xcolor}

\usepackage{libertine}
\usepackage{url}
\newmuskip\codemuskip
\codemuskip=4.0mu plus 2.0mu minus 2.0mu\relax
\newcommand\codeskip{\mskip\codemuskip}%
\let\codefont\textsf
\newcommand\sub[1]{\ensuremath{_{\text{#1}}}}

\usepackage{xspace}
\newcommand\keyw[1]{{\codefont{\textbf{#1}}}}
\newcommand\id[1]{\Varid{#1}}
\newcommand\idsym[1]{\mathbin{\id{#1}}}
\newcommand{\vertrule}[1][1.0ex]{\rule[-0.0ex]{.45pt}{#1}}

\usepackage[sort, numbers]{natbib}
\bibliographystyle{ACM-Reference-Format}
\defcitealias{embedding}{\textit{Folding Domain-Specific Languages: Deep and Shallow Embeddings}}

\usepackage{enumitem}
\usepackage{hyphenat}
\usepackage[switch]{lineno}
%\linenumbers

\usepackage{todonotes}
\usepackage{tikz-cd}


\title{\vspace{-10mm}An Overview of \citetalias{embedding}\vspace{-4mm}}
\author{Riley Evans (re17105)}
\date{\vspace{-3mm}}


%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput
%




\renewcommand\Varid[1]{\codefont{#1}}
\let\Conid\Varid

\begin{document}
\maketitle


\section{Introduction}

This is an overview of the techniques described in the paper \citetalias{embedding}.
The paper demonstrates a series of techniques that can be used when folding Domain Specific Languges.
It does so through the use of a simple parallel prefix circuit language~\cite{scans}.


In this overview a small parser combinator language embedded into Haskell will be used.
This language brings one key feature that was not described in the paper: how to apply these techniques to a typed language.
Only a minimal functionally complete set of combinators have been included in the language to keep it simple.
However, all other combinators usually found in a combinator language can be constructed from this set.



\section{Background}

\subsection{DSLs}

A Domain Specific Language (DSL) is a programming language that has a specialised domain or use-case.
This differs from a General Purpose Language (GPL), which can be applied across a larger set of domains.
DSLs can be split into two different categories: standalone and embedded. Standalone DSLs require their own compiler and typically have their own syntax.
Embedded DSLs use an exisiting language as a host, therefore they use the syntax and compiler from that language.
This means that they are easier to maintain and are often quicker to develop than standalone DSLs.

An embedded DSL can be implemented with two main techniques.
Firstly, a deep approach can be taken, this means that terms in the DSL will construct an Abstract Syntax Tree (AST) as a host language datatype.
This can then be used to apply optimisations and then evaluated.
A second approach known as a shallow embedding, is to define the terms as first class components of the language. An example of this could be a function in Haskell. This approach avoids the creation of an AST.


\subsection{Parsers}

A parser is a used to convert a series of tokens into another language.
For example converting a string into a Haskell datatype.
Parser combinators provide a flexible approach to constructing parsers.
Unlike parser generators, a combinator library is embedded within a host language: using combinators to construct the grammar.
This makes it a suitable to demonstrate the techniques described in this paper for folding the DSL to create parsers.

The language is made up of 6 terms, they provide all the essential operations needed in a parser.


\pagebreak
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}c<{\hspost}@{}}%
\column{32E}{@{}l@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}c<{\hspost}@{}}%
\column{46E}{@{}l@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{empty}{}\<[12]%
\>[12]{}\mathbin{::}\Conid{Parser}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{pure}{}\<[12]%
\>[12]{}\mathbin{::}\Varid{a}{}\<[32]%
\>[32]{}\to {}\<[32E]%
\>[36]{}\Conid{Parser}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{satisfy}{}\<[12]%
\>[12]{}\mathbin{::}(\Conid{Char}\to \Conid{Bool}){}\<[32]%
\>[32]{}\to {}\<[32E]%
\>[36]{}\Conid{Parser}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\Varid{try}{}\<[12]%
\>[12]{}\mathbin{::}\Conid{Parser}\codeskip \Varid{a}{}\<[32]%
\>[32]{}\to {}\<[32E]%
\>[36]{}\Conid{Parser}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{ap}{}\<[12]%
\>[12]{}\mathbin{::}\Conid{Parser}\codeskip (\Varid{a}\to \Varid{b}){}\<[32]%
\>[32]{}\to {}\<[32E]%
\>[36]{}\Conid{Parser}\codeskip \Varid{a}{}\<[46]%
\>[46]{}\to {}\<[46E]%
\>[50]{}\Conid{Parser}\codeskip \Varid{b}{}\<[E]%
\\
\>[3]{}\Varid{or}{}\<[12]%
\>[12]{}\mathbin{::}\Conid{Parser}\codeskip \Varid{a}{}\<[32]%
\>[32]{}\to {}\<[32E]%
\>[36]{}\Conid{Parser}\codeskip \Varid{a}{}\<[46]%
\>[46]{}\to {}\<[46E]%
\>[50]{}\Conid{Parser}\codeskip \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


For example, a parser that can parse the characters \ensuremath{\text{\ttfamily{\textquotesingle}a\textquotesingle}} or \ensuremath{\text{\ttfamily{\textquotesingle}b\textquotesingle}} can be defined as,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{aorb}\mathbin{::}\Conid{Parser}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\Varid{aorb}\mathrel{=}\Varid{satisfy}\codeskip (\equiv \text{\ttfamily{\textquotesingle}a\textquotesingle})\mathbin{\text{\`{}}\Varid{or}\text{\`{}}}\Varid{satisfy}\codeskip (\equiv \text{\ttfamily{\textquotesingle}b\textquotesingle}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A deep embedding of this parser language is defined in the algebraic datatype:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}c<{\hspost}@{}}%
\column{15E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}c<{\hspost}@{}}%
\column{37E}{@{}l@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{52}{@{}>{\hspre}c<{\hspost}@{}}%
\column{52E}{@{}l@{}}%
\column{56}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\codeskip \Conid{Parser}_{2}\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Empty}_{2}{}\<[15]%
\>[15]{}\mathbin{::}{}\<[15E]%
\>[19]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Pure}_{2}{}\<[15]%
\>[15]{}\mathbin{::}{}\<[15E]%
\>[19]{}\Varid{a}{}\<[37]%
\>[37]{}\to {}\<[37E]%
\>[41]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Satisfy}_{2}{}\<[15]%
\>[15]{}\mathbin{::}{}\<[15E]%
\>[19]{}(\Conid{Char}\to \Conid{Bool}){}\<[37]%
\>[37]{}\to {}\<[37E]%
\>[41]{}\Conid{Parser}_{2}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Try}_{2}{}\<[15]%
\>[15]{}\mathbin{::}{}\<[15E]%
\>[19]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[37]%
\>[37]{}\to {}\<[37E]%
\>[41]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Ap}_{2}{}\<[15]%
\>[15]{}\mathbin{::}{}\<[15E]%
\>[19]{}\Conid{Parser}_{2}\codeskip (\Varid{a}\to \Varid{b}){}\<[37]%
\>[37]{}\to {}\<[37E]%
\>[41]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[52]%
\>[52]{}\to {}\<[52E]%
\>[56]{}\Conid{Parser}_{2}\codeskip \Varid{b}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Or}_{2}{}\<[15]%
\>[15]{}\mathbin{::}{}\<[15E]%
\>[19]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[37]%
\>[37]{}\to {}\<[37E]%
\>[41]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[52]%
\>[52]{}\to {}\<[52E]%
\>[56]{}\Conid{Parser}_{2}\codeskip \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This can be interpreted by defining a function such as \ensuremath{\Varid{size}}, which finds the size of the AST used to construct the parser.
\ensuremath{\Varid{size}} interprets the deep embedding, by folding over the datatype.
See the appendix~\ref{app:shallow-size} for how to add an interpretation with a shallow embedding.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}c<{\hspost}@{}}%
\column{23E}{@{}l@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{40}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\codeskip \Conid{Size}\mathrel{=}\Conid{Int}{}\<[E]%
\\
\>[3]{}\Varid{size}\mathbin{::}\Conid{Parser}_{2}\codeskip \Varid{a}\to \Conid{Size}{}\<[E]%
\\
\>[3]{}\Varid{size}\codeskip {}\<[9]%
\>[9]{}\Conid{Empty}_{2}{}\<[23]%
\>[23]{}\mathrel{=}{}\<[23E]%
\>[26]{}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{size}\codeskip {}\<[9]%
\>[9]{}(\Conid{Pure}_{2}\codeskip \anonymous ){}\<[23]%
\>[23]{}\mathrel{=}{}\<[23E]%
\>[26]{}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{size}\codeskip {}\<[9]%
\>[9]{}(\Conid{Satisfy}_{2}\codeskip \anonymous ){}\<[23]%
\>[23]{}\mathrel{=}{}\<[23E]%
\>[26]{}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{size}\codeskip {}\<[9]%
\>[9]{}(\Conid{Try}_{2}\codeskip \Varid{px}){}\<[23]%
\>[23]{}\mathrel{=}{}\<[23E]%
\>[26]{}\mathrm{1}\mathbin{+}{}\<[31]%
\>[31]{}\Varid{size}\codeskip \Varid{px}{}\<[E]%
\\
\>[3]{}\Varid{size}\codeskip {}\<[9]%
\>[9]{}(\Conid{Ap}_{2}\codeskip \Varid{pf}\codeskip \Varid{px}){}\<[23]%
\>[23]{}\mathrel{=}{}\<[23E]%
\>[26]{}\mathrm{1}\mathbin{+}{}\<[31]%
\>[31]{}\Varid{size}\codeskip \Varid{pf}{}\<[40]%
\>[40]{}\mathbin{+}\Varid{size}\codeskip \Varid{px}{}\<[E]%
\\
\>[3]{}\Varid{size}\codeskip {}\<[9]%
\>[9]{}(\Conid{Or}_{2}\codeskip \Varid{px}\codeskip \Varid{py}){}\<[23]%
\>[23]{}\mathrel{=}{}\<[23E]%
\>[26]{}\mathrm{1}\mathbin{+}{}\<[31]%
\>[31]{}\Varid{size}\codeskip \Varid{px}{}\<[40]%
\>[40]{}\mathbin{+}\Varid{size}\codeskip \Varid{py}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\section{Folds}

It is possible to capture the shape of an abstract datatype as a \ensuremath{\Conid{Functor}}.
The use of a \ensuremath{\Conid{Functor}} allows for the specification of where a datatype recurses.
There is, however, one problem: a \ensuremath{\Conid{Functor}} expressing the parser language is required to be typed.
Parsers require the type of the tokens being parsed.
For example, a parser reading tokens that make up an expression could have the type \ensuremath{\Conid{Parser}\codeskip \Conid{Expr}}.
A \ensuremath{\Conid{Functor}} does not retain the type of the parser. Instead a type class called \ensuremath{\Conid{IFunctor}} will be used,
which is able to maintain the type indicies~\cite{mcbride2011functional}.
This can be thought of as a functor transformer:
it is able to change the structure of a functor whilst preserving the values inside it.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\codeskip \Conid{IFunctor}\codeskip \Varid{iF}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\mathbin{::}(\forall \Varid{a}\hsforall \hsdot{\cdot }{.}\Varid{f}\codeskip \Varid{a}\to \Varid{g}\codeskip \Varid{a})\to \Varid{iF}\codeskip \Varid{f}\codeskip \Varid{a}\to \Varid{iF}\codeskip \Varid{g}\codeskip \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The shape of \ensuremath{\Conid{Parser}_{2}}, can be seen in \ensuremath{\Conid{ParserF}} where the \ensuremath{\Varid{f}\codeskip \Varid{a}} marks the recursive spots.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\codeskip \Conid{ParserF}\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{EmptyF}{}\<[14]%
\>[14]{}\mathbin{::}\Conid{ParserF}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{PureF}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{a}{}\<[33]%
\>[33]{}\to \Conid{ParserF}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{SatisfyF}\mathbin{::}(\Conid{Char}\to \Conid{Bool}){}\<[33]%
\>[33]{}\to \Conid{ParserF}\codeskip \Varid{f}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{TryF}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{f}\codeskip \Varid{a}{}\<[33]%
\>[33]{}\to \Conid{ParserF}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{ApF}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{f}\codeskip (\Varid{a}\to \Varid{b}){}\<[33]%
\>[33]{}\to \Varid{f}\codeskip \Varid{a}{}\<[42]%
\>[42]{}\to \Conid{ParserF}\codeskip \Varid{f}\codeskip \Varid{b}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{OrF}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{f}\codeskip \Varid{a}{}\<[33]%
\>[33]{}\to \Varid{f}\codeskip \Varid{a}{}\<[42]%
\>[42]{}\to \Conid{ParserF}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The \ensuremath{\Conid{IFunctor}} instance can be found in the appendix~\ref{app:ifunctor-parserf}.
It follows the same structure as a standard \ensuremath{\Conid{Functor}} instance.


\ensuremath{\Conid{Fix}} is used to get the fixed point of a functor.
It provides the structure needed to allow the datatype to recursive.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{newtype}\codeskip \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}\mathrel{=}\Conid{In}\codeskip (\Varid{iF}\codeskip (\Conid{Fix}\codeskip \Varid{iF})\codeskip \Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\ensuremath{\Conid{Parser}_{4}} is the fixed point of \ensuremath{\Conid{ParserF}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\codeskip \Conid{Parser}_{4}\codeskip \Varid{a}\mathrel{=}\Conid{Fix}\codeskip \Conid{ParserF}\codeskip \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A mechanism is now required for folding this abstract datatype.
This is possible through the use of a \textit{catamorphism}, which is a generalised way of folding an abstract datatype.
The commutative diagram below describes how a \textit{catamorphism} can be defined.
Firstly, a layer of \ensuremath{\Conid{Fix}} is peeled off by removing an \ensuremath{\Conid{In}} to give \ensuremath{\Varid{iF}\codeskip (\Conid{Fix}\codeskip \Varid{iF})\codeskip \Varid{a}}.
Then a recursive call is made to fold the structure below in the AST.
This results in a item of type \ensuremath{\Varid{iF}\codeskip \Varid{f}\codeskip \Varid{a}}.
Finally, an algebra is applied to fold this layer of the datatype, resulting in a item of type \ensuremath{\Varid{f}\codeskip \Varid{a}}.

\begin{figure}[h]
\centering
\begin{tikzcd}[column sep=huge]
\ensuremath{\Varid{iF}\codeskip (\Conid{Fix}\codeskip \Varid{iF})\codeskip \Varid{a}}  \arrow[r, "\ensuremath{\Varid{imap}\codeskip (\Varid{cata}\codeskip \Varid{alg})}"] \arrow[d, shift left=0.15cm, "\ensuremath{\Conid{In}}"] & \ensuremath{\Varid{iF}\codeskip \Varid{f}\codeskip \Varid{a}} \arrow[d, "\ensuremath{\Varid{alg}}"]\\
\ensuremath{\Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}}       \arrow[r, "\ensuremath{\Varid{cata}\codeskip \Varid{alg}}"]        \arrow[u, shift left=0.15cm, "\ensuremath{\Varid{inop}}"]        & \ensuremath{\Varid{f}\codeskip \Varid{a}}
\end{tikzcd}
\end{figure}


\ensuremath{\Varid{cata}} is able to fold a \ensuremath{\Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}} and produce an item of type \ensuremath{\Varid{f}\codeskip \Varid{a}}.
It uses the algebra argument as a specification of how to fold the input datatype.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{cata}\mathbin{::}\Conid{IFunctor}\codeskip \Varid{iF}\Rightarrow (\forall \Varid{a}\hsforall \hsdot{\cdot }{.}\Varid{iF}\codeskip \Varid{f}\codeskip \Varid{a}\to \Varid{f}\codeskip \Varid{a})\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}\to \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{cata}\codeskip \Varid{alg}\codeskip (\Conid{In}\codeskip \Varid{x})\mathrel{=}\Varid{alg}\codeskip (\Varid{imap}\codeskip (\Varid{cata}\codeskip \Varid{alg})\codeskip \Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Since the resulting type of \ensuremath{\Varid{cata}} for an \ensuremath{\Conid{IFunctor}} is \ensuremath{\Varid{f}\codeskip \Varid{a}}, this requires the output to be a \ensuremath{\Conid{Functor}}.
One example of this could be \ensuremath{\Conid{Fix}\codeskip \Conid{ParserF}}.
However, in the case that the datatype would like to be folded into something that is not a functor,
or has kind \ensuremath{\mathbin{*}}, then additional infrastructure is needed.
There are two methods to allow this to take place.
A new type could be defined for each output type that has a phantom type parameter. For example:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{newtype}\codeskip \Conid{Size}'\codeskip \Varid{i}\mathrel{=}\Conid{Size}'\codeskip \{\mskip1.5mu \Varid{unSize}\mathbin{::}\Conid{Size}\mskip1.5mu\}\codeskip \mathbf{deriving}\codeskip \Conid{Num}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
However, this could lead to lots of new type definitions.
To avoid this the constant functor can be used.
It allows a type with kind \ensuremath{\mathbin{*}} to have kind \ensuremath{\mathbin{*}\to \mathbin{*}}, in a similar way to how the \ensuremath{\Varid{const}} function works.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{newtype}\codeskip \Conid{C}\codeskip \Varid{a}\codeskip \Varid{k}\mathrel{=}\Conid{C}\codeskip \{\mskip1.5mu \Varid{unConst}\mathbin{::}\Varid{a}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now, all the building blocks have been defined that allow for the folding of the parser DSL.
\ensuremath{\Varid{size}} can be redefined as a fold, that is determined by the \ensuremath{\Varid{sizeAlg}}.
Due to parsers being a typed language, a constant functor is required to preserve the type indices.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\codeskip \Conid{ParserAlg}\codeskip \Varid{f}\codeskip \Varid{a}\mathrel{=}\Conid{ParserF}\codeskip \Varid{f}\codeskip \Varid{a}\to \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{sizeAlg}\mathbin{::}\Conid{ParserAlg}\codeskip (\Conid{C}\codeskip \Conid{Size})\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{sizeAlg}\codeskip \Conid{EmptyF}{}\<[26]%
\>[26]{}\mathrel{=}\Conid{C}\codeskip \mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{sizeAlg}\codeskip (\Conid{PureF}\codeskip {}\<[22]%
\>[22]{}\anonymous ){}\<[26]%
\>[26]{}\mathrel{=}\Conid{C}\codeskip \mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{sizeAlg}\codeskip (\Conid{SatisfyF}\codeskip {}\<[22]%
\>[22]{}\anonymous ){}\<[26]%
\>[26]{}\mathrel{=}\Conid{C}\codeskip \mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{sizeAlg}\codeskip (\Conid{TryF}\codeskip (\Conid{C}\codeskip \Varid{n})){}\<[26]%
\>[26]{}\mathrel{=}\Conid{C}\codeskip (\Varid{n}\mathbin{+}\mathrm{1}){}\<[E]%
\\
\>[3]{}\Varid{sizeAlg}\codeskip (\Conid{ApF}\codeskip (\Conid{C}\codeskip \Varid{pf})\codeskip (\Conid{C}\codeskip \Varid{px}))\mathrel{=}\Conid{C}\codeskip (\Varid{pf}\mathbin{+}\Varid{px}\mathbin{+}\mathrm{1}){}\<[E]%
\\
\>[3]{}\Varid{sizeAlg}\codeskip (\Conid{OrF}\codeskip (\Conid{C}\codeskip \Varid{px})\codeskip (\Conid{C}\codeskip \Varid{py}))\mathrel{=}\Conid{C}\codeskip (\Varid{px}\mathbin{+}\Varid{py}\mathbin{+}\mathrm{1}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{size}_{4}\mathbin{::}\Conid{Parser}_{4}\codeskip \Varid{a}\to \Conid{Size}{}\<[E]%
\\
\>[3]{}\Varid{size}_{4}\mathrel{=}\Varid{unConst}\hsdot{\cdot }{.}\Varid{cata}\codeskip \Varid{sizeAlg}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Multiple Interpretations}

In DSLs it is common to want to evaluate multiple interpretations.
For example, a parser may also want to know the maximum number of characters it will read (maximum munch).
In a deep embedding, this is simple: a second algebra can be defined.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\codeskip \Conid{MM}\mathrel{=}\Conid{Int}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{mmAlg}\mathbin{::}\Conid{ParserAlg}\codeskip (\Conid{C}\codeskip \Conid{MM})\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{mmAlg}\codeskip \Conid{EmptyF}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{C}\codeskip \mathrm{0}{}\<[E]%
\\
\>[3]{}\Varid{mmAlg}\codeskip (\Conid{PureF}\codeskip \anonymous ){}\<[24]%
\>[24]{}\mathrel{=}\Conid{C}\codeskip \mathrm{0}{}\<[E]%
\\
\>[3]{}\Varid{mmAlg}\codeskip (\Conid{SatisfyF}\codeskip \Varid{c}){}\<[24]%
\>[24]{}\mathrel{=}\Conid{C}\codeskip \mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{mmAlg}\codeskip (\Conid{TryF}\codeskip (\Conid{C}\codeskip \Varid{px})){}\<[24]%
\>[24]{}\mathrel{=}\Conid{C}\codeskip \Varid{px}{}\<[E]%
\\
\>[3]{}\Varid{mmAlg}\codeskip (\Conid{ApF}\codeskip (\Conid{C}\codeskip \Varid{pf})\codeskip (\Conid{C}\codeskip \Varid{px})){}\<[30]%
\>[30]{}\mathrel{=}\Conid{C}\codeskip (\Varid{pf}\mathbin{+}\Varid{px}){}\<[E]%
\\
\>[3]{}\Varid{mmAlg}\codeskip (\Conid{OrF}\codeskip (\Conid{C}\codeskip \Varid{px})\codeskip (\Conid{C}\codeskip \Varid{py})){}\<[30]%
\>[30]{}\mathrel{=}\Conid{C}\codeskip (\Varid{max}\codeskip \Varid{px}\codeskip \Varid{py}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{maxMunch}_{4}\mathbin{::}\Conid{Parser}_{4}\codeskip \Varid{a}\to \Conid{MM}{}\<[E]%
\\
\>[3]{}\Varid{maxMunch}_{4}\mathrel{=}\Varid{unConst}\hsdot{\cdot }{.}\Varid{cata}\codeskip \Varid{mmAlg}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

However, in a shallow embedding it is not as easy.
To be able to evaluate both semantics a pair can be used, with both interpretations being evaluated simultaneously.
If many semantics are required this can become cumbersome to define.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\codeskip \Conid{Parser}_{5}\mathrel{=}(\Conid{Size},\Conid{MM}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{size}_{5}\mathbin{::}\Conid{Parser}_{5}\to \Conid{Size}{}\<[E]%
\\
\>[3]{}\Varid{size}_{5}\mathrel{=}\Varid{fst}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{maxMunch}_{5}\mathbin{::}\Conid{Parser}_{5}\to \Conid{Size}{}\<[E]%
\\
\>[3]{}\Varid{maxMunch}_{5}\mathrel{=}\Varid{snd}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{smmAlg}\mathbin{::}\Conid{ParserAlg}\codeskip (\Conid{C}\codeskip (\Conid{Size},\Conid{MM}))\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{smmAlg}\codeskip \Conid{EmptyF}{}\<[30]%
\>[30]{}\mathrel{=}\Conid{C}\codeskip (\mathrm{1},{}\<[43]%
\>[43]{}\mathrm{0}){}\<[E]%
\\
\>[3]{}\Varid{smmAlg}\codeskip (\Conid{PureF}\codeskip \anonymous ){}\<[30]%
\>[30]{}\mathrel{=}\Conid{C}\codeskip (\mathrm{1},{}\<[43]%
\>[43]{}\mathrm{0}){}\<[E]%
\\
\>[3]{}\Varid{smmAlg}\codeskip (\Conid{SatisfyF}\codeskip \Varid{c}){}\<[30]%
\>[30]{}\mathrel{=}\Conid{C}\codeskip (\mathrm{1},{}\<[43]%
\>[43]{}\mathrm{1}){}\<[E]%
\\
\>[3]{}\Varid{smmAlg}\codeskip (\Conid{TryF}\codeskip (\Conid{C}\codeskip (\Varid{s},\Varid{mm}))){}\<[30]%
\>[30]{}\mathrel{=}\Conid{C}\codeskip (\Varid{s}\mathbin{+}\mathrm{1},{}\<[43]%
\>[43]{}\Varid{mm}){}\<[E]%
\\
\>[3]{}\Varid{smmAlg}\codeskip (\Conid{ApF}\codeskip {}\<[16]%
\>[16]{}(\Conid{C}\codeskip (\Varid{s},\Varid{mm}))\codeskip (\Conid{C}\codeskip (\Varid{s}',\Varid{mm'}))){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\Conid{C}\codeskip (\Varid{s}\mathbin{+}\Varid{s}'\mathbin{+}\mathrm{1},\Varid{mm}\mathbin{+}\Varid{mm'}){}\<[E]%
\\
\>[3]{}\Varid{smmAlg}\codeskip (\Conid{OrF}\codeskip {}\<[16]%
\>[16]{}(\Conid{C}\codeskip (\Varid{s},\Varid{mm}))\codeskip (\Conid{C}\codeskip (\Varid{s}',\Varid{mm'}))){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathrel{=}\Conid{C}\codeskip (\Varid{s}\mathbin{+}\Varid{s}'\mathbin{+}\mathrm{1},\Varid{max}\codeskip \Varid{mm}\codeskip \Varid{mm'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

It is possible to take an alegbra and convert it into a shallow embedding.
This is possible by setting the shallow embedding equal to the result of the algebra,
with the corresponding constructor from the deep embedding, for example:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ap}_{5}\codeskip \Varid{pf}\codeskip \Varid{px}\mathrel{=}\Varid{smmAlg}\codeskip (\Conid{ApF}\codeskip \Varid{pf}\codeskip \Varid{px}){}\<[E]%
\\
\>[3]{}\Varid{or}_{5}\codeskip \Varid{px}\codeskip \Varid{py}\mathrel{=}\Varid{smmAlg}\codeskip (\Conid{OrF}\codeskip \Varid{px}\codeskip \Varid{py}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Dependent Interpretations}

In a more complex parser combinator library that perform optimisations on a deep embedding,
it could also be possible that there is a primary fold that depends on other secondary folds on parts of the AST.
Folds such as this are named \textit{zygomorphisms}~\cite{Fokkinga1989TuplingAM} - a special case of a \textit{mutomorphism} -
they can be implemented by tupling the functions in the fold.
\citet{parsley} makes use of a \textit{zygomorphism} to perform consumption analysis.


\subsection{Context-sensitive Interpretations}

Parsers themselves inherently require context sensitive interpretations - what can be parsed will
depend on what has previously been parsed.

A parser can be implemented with an accumulating fold.
An accumulating fold forms series of nested functions, that collapse to give a final value once the base case has been applied.
A simple example of an accumulating fold could be, implementing \ensuremath{\Varid{foldl}} in terms of \ensuremath{\Varid{foldr}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{foldl}\mathbin{::}(\Varid{b}\to \Varid{a}\to \Varid{b})\to \Varid{b}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to \Varid{b}{}\<[E]%
\\
\>[3]{}\Varid{foldl}\codeskip \Varid{f}\codeskip \Varid{b}\codeskip \Varid{as}\mathrel{=}\Varid{foldr}\codeskip (\lambda \Varid{a}\codeskip \Varid{g}\codeskip \Varid{x}\to \Varid{g}\codeskip (\Varid{f}\codeskip \Varid{x}\codeskip \Varid{a}))\codeskip \Varid{id}\codeskip \Varid{as}\codeskip \Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A simple example of \ensuremath{\Varid{foldl}} can be considered.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}c<{\hspost}@{}}%
\column{BE}{@{}l@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{foldl}\codeskip (\mathbin{+})\codeskip \mathrm{0}\codeskip [\mskip1.5mu \mathrm{1},\mathrm{2}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\equiv {}\<[BE]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\lambda \Varid{x}\to (\lambda \Varid{x}\to \Varid{id}\codeskip (\Varid{x}\mathbin{+}\mathrm{2}))\codeskip (\Varid{x}\mathbin{+}\mathrm{1}))\codeskip \mathrm{0}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Yoda~\cite{wuYoda} is a simple non-deterministic parser combinator library.
The combinators are used to produce a function of type \ensuremath{\Varid{parser}\mathbin{::}\Conid{String}\to [\mskip1.5mu (\Varid{a},\Conid{String})\mskip1.5mu]}.
Similarities can be drawn from the previous example, the combinators form the first part of the example where a function is constructed of lambdas.
The base case \ensuremath{\mathrm{0}} of the fold is then passed into the constructed function, this similar to how a string is passed into the parsing function.
The accumulating fold for Yoda, is implemented by \ensuremath{\Varid{yAlg}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{newtype}\codeskip \Conid{Y}\codeskip \Varid{a}\mathrel{=}\Conid{Y}\codeskip \{\mskip1.5mu \Varid{unYoda}\mathbin{::}\Conid{String}\to [\mskip1.5mu (\Varid{a},\Conid{String})\mskip1.5mu]\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{yAlg}\mathbin{::}\Conid{ParserAlg}\codeskip \Conid{Y}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{yAlg}\codeskip {}\<[9]%
\>[9]{}\Conid{EmptyF}{}\<[23]%
\>[23]{}\mathrel{=}\Conid{Y}\codeskip (\Varid{const}\codeskip [\mskip1.5mu \mskip1.5mu]){}\<[E]%
\\
\>[3]{}\Varid{yAlg}\codeskip {}\<[9]%
\>[9]{}(\Conid{PureF}\codeskip \Varid{x}){}\<[23]%
\>[23]{}\mathrel{=}\Conid{Y}\codeskip (\lambda \Varid{ts}\to [\mskip1.5mu (\Varid{x},\Varid{ts})\mskip1.5mu]){}\<[E]%
\\
\>[3]{}\Varid{yAlg}\codeskip {}\<[9]%
\>[9]{}(\Conid{SatisfyF}\codeskip \Varid{c}){}\<[23]%
\>[23]{}\mathrel{=}\Conid{Y}\codeskip (\lambda \mathbf{case}{}\<[E]%
\\
\>[9]{}[\mskip1.5mu \mskip1.5mu]{}\<[18]%
\>[18]{}\to [\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[9]{}(\Varid{t}\mathbin{:}\Varid{ts}'){}\<[18]%
\>[18]{}\to [\mskip1.5mu (\Varid{t},\Varid{ts}')\mid \Varid{c}\codeskip \Varid{t}\mskip1.5mu]){}\<[E]%
\\
\>[3]{}\Varid{yAlg}\codeskip {}\<[9]%
\>[9]{}(\Conid{TryF}\codeskip \Varid{px}){}\<[23]%
\>[23]{}\mathrel{=}\Varid{px}{}\<[E]%
\\
\>[3]{}\Varid{yAlg}\codeskip {}\<[9]%
\>[9]{}(\Conid{ApF}\codeskip (\Conid{Y}\codeskip \Varid{pf})\codeskip (\Conid{Y}\codeskip \Varid{px}))\mathrel{=}\Conid{Y}\codeskip (\lambda \Varid{ts}\to {}\<[E]%
\\
\>[9]{}[\mskip1.5mu (\Varid{f}\codeskip \Varid{x},\Varid{ts}''){}\<[23]%
\>[23]{}\mid {}\<[27]%
\>[27]{}(\Varid{f},{}\<[32]%
\>[32]{}\Varid{ts}'){}\<[39]%
\>[39]{}\leftarrow \Varid{pf}\codeskip \Varid{ts}{}\<[E]%
\\
\>[23]{},{}\<[27]%
\>[27]{}(\Varid{x},{}\<[32]%
\>[32]{}\Varid{ts}''){}\<[39]%
\>[39]{}\leftarrow \Varid{px}\codeskip \Varid{ts}'\mskip1.5mu]){}\<[E]%
\\
\>[3]{}\Varid{yAlg}\codeskip {}\<[9]%
\>[9]{}(\Conid{OrF}\codeskip (\Conid{Y}\codeskip \Varid{px})\codeskip (\Conid{Y}\codeskip \Varid{py}))\mathrel{=}\Conid{Y}\codeskip (\lambda \Varid{ts}\to \Varid{px}\codeskip \Varid{ts}\plus \Varid{py}\codeskip \Varid{ts}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{parse}\mathbin{::}\Conid{Parser}_{4}\codeskip \Varid{a}\to \Conid{String}\to [\mskip1.5mu (\Varid{a},\Conid{String})\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\Varid{parse}\mathrel{=}\Varid{unYoda}\hsdot{\cdot }{.}\Varid{cata}\codeskip \Varid{yAlg}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Parameterized Interpretations}


Previously, when defining multiple interpretations in a shallow embedding, a tuple was used.
However, this does not extend well when many interpretations are needed.
Large tuples tend to lack good language support and will become messy to work with.
It would be beneficial if a shallow embedding could be parameterised to take an interpretation in the form of an algebra.

\ensuremath{\Conid{Parser}_{7}} allows for this approach,
the shallow embedding is made up of first class functions that require an algebra argument.
This algebra describes how the shallow embedding should fold the structure.
The full definitions can be found in Appendix~\ref{app:parser7-constructors}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{newtype}\codeskip \Conid{Parser}_{7}\codeskip \Varid{a}\mathrel{=}\Conid{P}_{7}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\{\mskip1.5mu \Varid{unP}_{7}\mathbin{::}\forall \Varid{f}\hsforall \hsdot{\cdot }{.}(\forall \Varid{a}\hsforall \hsdot{\cdot }{.}\Conid{ParserAlg}\codeskip \Varid{f}\codeskip \Varid{a})\to \Varid{f}\codeskip \Varid{a}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{satisfy}_{7}\mathbin{::}(\Conid{Char}\to \Conid{Bool})\to \Conid{Parser}_{7}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\Varid{satisfy}_{7}\codeskip \Varid{c}\mathrel{=}\Conid{P}_{7}\codeskip (\lambda \Varid{h}\to \Varid{h}\codeskip (\Conid{SatisfyF}\codeskip \Varid{c})){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{or}_{7}\mathbin{::}\Conid{Parser}_{7}\codeskip \Varid{a}\to \Conid{Parser}_{7}\codeskip \Varid{a}\to \Conid{Parser}_{7}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{or}_{7}\codeskip \Varid{px}\codeskip \Varid{py}\mathrel{=}\Conid{P}_{7}\codeskip (\lambda \Varid{h}\to \Varid{h}\codeskip (\Conid{OrF}\codeskip (\Varid{unP}_{7}\codeskip \Varid{px}\codeskip \Varid{h})\codeskip (\Varid{unP}_{7}\codeskip \Varid{py}\codeskip \Varid{h}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Then, for example, to find the size of a parser:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{size}_{7}\mathbin{::}\Conid{Parser}_{7}\codeskip \Varid{a}\to \Conid{Size}{}\<[E]%
\\
\>[3]{}\Varid{size}_{7}\codeskip \Varid{p}\mathrel{=}\Varid{unConst}\codeskip (\Varid{unP}_{7}\codeskip \Varid{p}\codeskip \Varid{sizeAlg}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

One benefit of this approach is that it allows the shallow embedding to be converted to a deep embedding.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{deep}\mathbin{::}\Conid{Parser}_{7}\codeskip \Varid{a}\to \Conid{Parser}_{4}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{deep}\codeskip \Varid{parser}\mathrel{=}\Varid{unP}_{7}\codeskip \Varid{parser}\codeskip \Conid{In}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Simillarly it is possible to convert a deep embedding into a parameterised shallow embedding.
Where \ensuremath{\Varid{shallowAlg}} is setting each constructor to the corresponding shallow function - this can be seen in Appendix~\ref{app:shallowalg}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{shallow}\mathbin{::}\Conid{Parser}_{4}\codeskip \Varid{a}\to \Conid{Parser}_{7}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{shallow}\mathrel{=}\Varid{cata}\codeskip \Varid{shallowAlg}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



Being able to convert between both types of embedding,
demonstrates that deep and parameterised shallow embeddings are inverses of each other.


\subsection{Implicitly Parameterized Interpretations}

The previous parameterised implementation still required the algebra to be specified.
It would be helpful if it could be passed implicitly, if it can be determined from the type of the interpretation.
This is possible in Haskell through the use of a type class.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\codeskip \Conid{Parser}_{8}\codeskip \Varid{parser}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{empty}_{8}{}\<[15]%
\>[15]{}\mathbin{::}\Varid{parser}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pure}_{8}{}\<[15]%
\>[15]{}\mathbin{::}\Varid{a}{}\<[35]%
\>[35]{}\to \Varid{parser}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{satisfy}_{8}{}\<[15]%
\>[15]{}\mathbin{::}(\Conid{Char}\to \Conid{Bool}){}\<[35]%
\>[35]{}\to \Varid{parser}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{try}_{8}{}\<[15]%
\>[15]{}\mathbin{::}\Varid{parser}\codeskip \Varid{a}{}\<[35]%
\>[35]{}\to \Varid{parser}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ap}_{8}{}\<[15]%
\>[15]{}\mathbin{::}\Varid{parser}\codeskip (\Varid{a}\to \Varid{b}){}\<[35]%
\>[35]{}\to \Varid{parser}\codeskip \Varid{a}\to \Varid{parser}\codeskip \Varid{b}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{or}_{8}{}\<[15]%
\>[15]{}\mathbin{::}\Varid{parser}\codeskip \Varid{a}{}\<[35]%
\>[35]{}\to \Varid{parser}\codeskip \Varid{a}\to \Varid{parser}\codeskip \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\codeskip \Conid{Parser}_{8}\codeskip \Conid{Size}'\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{empty}_{8}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{Size}'\codeskip \mathrm{1}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pure}_{8}\codeskip \anonymous {}\<[17]%
\>[17]{}\mathrel{=}\Conid{Size}'\codeskip \mathrm{1}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{satisfy}_{8}\codeskip \anonymous {}\<[17]%
\>[17]{}\mathrel{=}\Conid{Size}'\codeskip \mathrm{1}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{try}_{8}\codeskip \Varid{px}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{Size}'\codeskip (\Varid{unSize}\codeskip \Varid{px}{}\<[37]%
\>[37]{}\mathbin{+}\mathrm{1}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ap}_{8}\codeskip \Varid{pf}\codeskip \Varid{px}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{Size}'\codeskip (\Varid{unSize}\codeskip \Varid{pf}{}\<[37]%
\>[37]{}\mathbin{+}\Varid{unSize}\codeskip \Varid{px}{}\<[50]%
\>[50]{}\mathbin{+}\mathrm{1}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{or}_{8}\codeskip \Varid{px}\codeskip \Varid{py}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{Size}'\codeskip (\Varid{unSize}\codeskip \Varid{px}{}\<[37]%
\>[37]{}\mathbin{+}\Varid{unSize}\codeskip \Varid{py}{}\<[50]%
\>[50]{}\mathbin{+}\mathrm{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
%|coerce| allows for conversion between types that have the same runtime representation.
%This is the case for |Size8| and |Int|.

To be able to reuse the previously defined algebras, a different type class can be defined.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\codeskip \Conid{Parser}_{9}\codeskip \Varid{parser}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{alg}\mathbin{::}\Conid{ParserAlg}\codeskip \Varid{parser}\codeskip \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{Parser}_{9}\codeskip \Conid{Size}'\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{alg}\mathrel{=}\Conid{Size}'\hsdot{\cdot }{.}\Varid{unConst}\hsdot{\cdot }{.}\Varid{sizeAlg}\hsdot{\cdot }{.}\Varid{imap}\codeskip (\Conid{C}\hsdot{\cdot }{.}\Varid{unSize}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\subsection{Modular Interpretations}


There may be times when adding extra combinators would be convenient.
For example, adding a `string' operator.
A modular technique for assembling DSLs would aid this process.
This approach is described in Data types Ã  la carte~\cite{datatypesalacarte}.
An \ensuremath{:\!\!+\!\!:} operator can be defined to specify a choice between constructors.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\codeskip (\Varid{iF}:\!\!+\!\!:\Varid{iG})\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{L}\mathbin{::}\Varid{iF}\codeskip \Varid{f}\codeskip \Varid{a}\to (\Varid{iF}:\!\!+\!\!:\Varid{iG})\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{R}\mathbin{::}\Varid{iG}\codeskip \Varid{f}\codeskip \Varid{a}\to (\Varid{iF}:\!\!+\!\!:\Varid{iG})\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\mathbf{infixr}:\!\!+\!\!:{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip {}\<[13]%
\>[13]{}(\Conid{IFunctor}\codeskip \Varid{iF},\Conid{IFunctor}\codeskip \Varid{iG}){}\<[E]%
\\
\>[13]{}\Rightarrow \Conid{IFunctor}\codeskip (\Varid{iF}:\!\!+\!\!:\Varid{iG})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip {}\<[11]%
\>[11]{}\Varid{f}\codeskip (\Conid{L}\codeskip \Varid{x}){}\<[20]%
\>[20]{}\mathrel{=}\Conid{L}\codeskip {}\<[25]%
\>[25]{}(\Varid{imap}\codeskip {}\<[32]%
\>[32]{}\Varid{f}\codeskip {}\<[35]%
\>[35]{}\Varid{x}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip {}\<[11]%
\>[11]{}\Varid{f}\codeskip (\Conid{R}\codeskip \Varid{y}){}\<[20]%
\>[20]{}\mathrel{=}\Conid{R}\codeskip {}\<[25]%
\>[25]{}(\Varid{imap}\codeskip {}\<[32]%
\>[32]{}\Varid{f}\codeskip {}\<[35]%
\>[35]{}\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For each constructor that is required the datatype and \ensuremath{\Conid{IFunctor}} instance can be defined.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\codeskip \Conid{Ap}_{10}\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Ap}_{10}\mathbin{::}\Varid{f}\codeskip (\Varid{a}\to \Varid{b})\to \Varid{f}\codeskip \Varid{a}\to \Conid{Ap}_{10}\codeskip \Varid{f}\codeskip \Varid{b}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Conid{Ap}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \Varid{f}\codeskip (\Conid{Ap}_{10}\codeskip \Varid{pf}\codeskip \Varid{px})\mathrel{=}\Conid{Ap}_{10}\codeskip (\Varid{f}\codeskip \Varid{pf})\codeskip (\Varid{f}\codeskip \Varid{px}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
All datatypes and instances can be found in Appendix~\ref{app:modular-dtypes-ifunctors}

The datatypes are now summed together to form a single \ensuremath{\Conid{ParserF}_{10}} type.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}c<{\hspost}@{}}%
\column{19E}{@{}l@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}c<{\hspost}@{}}%
\column{33E}{@{}l@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}c<{\hspost}@{}}%
\column{46E}{@{}l@{}}%
\column{51}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\codeskip \Conid{ParserF}_{10}{}\<[19]%
\>[19]{}\mathrel{=}{}\<[19E]%
\>[24]{}\Conid{Empty}_{10}{}\<[33]%
\>[33]{}:\!\!+\!\!:{}\<[33E]%
\>[38]{}\Conid{Pure}_{10}{}\<[46]%
\>[46]{}:\!\!+\!\!:{}\<[46E]%
\>[51]{}\Conid{Satisfy}_{10}{}\<[E]%
\\
\>[19]{}:\!\!+\!\!:{}\<[19E]%
\>[24]{}\Conid{Try}_{10}{}\<[33]%
\>[33]{}:\!\!+\!\!:{}\<[33E]%
\>[38]{}\Conid{Ap}_{10}{}\<[46]%
\>[46]{}:\!\!+\!\!:{}\<[46E]%
\>[51]{}\Conid{Or}_{10}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{type}\codeskip \Conid{Parser}_{10}\mathrel{=}\Conid{Fix}\codeskip \Conid{ParserF}_{10}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
There is however, one problem with this approach: there is now a mess of \ensuremath{\Conid{L}} and \ensuremath{\Conid{R}}'s.
This makes this approach inconvenient to use.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{aorb}_{10}\mathbin{::}\Conid{Parser}_{10}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\Varid{aorb}_{10}\mathrel{=}\Conid{In}\codeskip (\Conid{R}\codeskip (\Conid{R}\codeskip (\Conid{R}\codeskip (\Conid{R}\codeskip (\Conid{R}\codeskip (\Conid{Or}_{10}{}\<[E]%
\\
\>[3]{}\hsindent{11}{}\<[14]%
\>[14]{}(\Conid{In}\codeskip (\Conid{R}\codeskip (\Conid{R}\codeskip (\Conid{L}\codeskip (\Conid{Satisfy}_{10}\codeskip (\equiv \text{\ttfamily{\textquotesingle}a\textquotesingle})))))){}\<[E]%
\\
\>[3]{}\hsindent{11}{}\<[14]%
\>[14]{}(\Conid{In}\codeskip (\Conid{R}\codeskip (\Conid{R}\codeskip (\Conid{L}\codeskip (\Conid{Satisfy}_{10}\codeskip (\equiv \text{\ttfamily{\textquotesingle}b\textquotesingle})))))))))))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Data types Ã  la carte~\cite{datatypesalacarte}, however, describes a technique that allows for the injection of these \ensuremath{\Conid{L}}'s and \ensuremath{\Conid{R}}'s.
The notion of subtypes between functors, can be specified using the \ensuremath{:\prec:} operator.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\codeskip (\Conid{IFunctor}\codeskip \Varid{iF},\Conid{IFunctor}\codeskip \Varid{iG})\Rightarrow \Varid{iF}:\prec:\Varid{iG}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}\mathbin{::}\Varid{iF}\codeskip \Varid{f}\codeskip \Varid{a}\to \Varid{iG}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Varid{iF}\Rightarrow \Varid{iF}:\prec:\Varid{iF}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}\mathrel{=}\Varid{id}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\newpage
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\codeskip {}\<[13]%
\>[13]{}\mbox{\enskip\{-\# OVERLAPPING  \#-\}\enskip}{}\<[E]%
\\
\>[13]{}(\Conid{IFunctor}\codeskip \Varid{iF},\Conid{IFunctor}\codeskip \Varid{iG}){}\<[E]%
\\
\>[13]{}\Rightarrow \Varid{iF}:\prec:(\Varid{iF}:\!\!+\!\!:\Varid{iG})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}{}\<[10]%
\>[10]{}\mathrel{=}\Conid{L}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip {}\<[13]%
\>[13]{}(\Conid{IFunctor}\codeskip \Varid{iF},\Conid{IFunctor}\codeskip \Varid{iG},{}\<[E]%
\\
\>[13]{}\Conid{IFunctor}\codeskip \Varid{iH},\Varid{iF}:\prec:\Varid{iG}){}\<[E]%
\\
\>[13]{}\Rightarrow \Varid{iF}:\prec:(\Varid{iH}:\!\!+\!\!:\Varid{iG})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{inj}\mathrel{=}\Conid{R}\hsdot{\cdot }{.}\Varid{inj}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Smart constructors are defined that allow for the \ensuremath{\Conid{L}}'s and \ensuremath{\Conid{R}}'s to be injected.
Two examples are given, the other smart constructors can be found in Appendix~\ref{app:modular-smart-constructors}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{satisfy}_{10}\mathbin{::}(\Conid{Satisfy}_{10}:\prec:\Varid{iF}){}\<[36]%
\>[36]{}\Rightarrow (\Conid{Char}\to \Conid{Bool}){}\<[E]%
\\
\>[3]{}\hsindent{32}{}\<[35]%
\>[35]{}\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\Varid{satisfy}_{10}\codeskip \Varid{c}\mathrel{=}\Conid{In}\codeskip (\Varid{inj}\codeskip (\Conid{Satisfy}_{10}\codeskip \Varid{c})){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{or}_{10}\mathbin{::}(\Conid{Or}_{10}:\prec:\Varid{iF})\Rightarrow \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{or}_{10}\codeskip \Varid{px}\codeskip \Varid{py}\mathrel{=}\Conid{In}\codeskip (\Varid{inj}\codeskip (\Conid{Or}_{10}\codeskip \Varid{px}\codeskip \Varid{py})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Now the smart constructors can be used to form an expression \ensuremath{\Varid{aorb}_{10}'}.
The type contraints on this expression allow for \ensuremath{\Varid{f}} to be flexible, so long as \ensuremath{\Conid{Or}_{10}} and \ensuremath{\Conid{Satisfy}_{10}} are subtypes of the functor \ensuremath{\Varid{f}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{aorb}_{10}'\mathbin{::}(\Conid{Or}_{10}:\prec:\Varid{iF},\Conid{Satisfy}_{10}:\prec:\Varid{iF})\Rightarrow \Conid{Fix}\codeskip \Varid{iF}\codeskip \Conid{Char}{}\<[E]%
\\
\>[3]{}\Varid{aorb}_{10}'\mathrel{=}\Varid{satisfy}_{10}\codeskip (\equiv \text{\ttfamily{\textquotesingle}a\textquotesingle})\mathbin{\text{\`{}}\Varid{or}_{10}\text{\`{}}}\Varid{satisfy}_{10}\codeskip (\equiv \text{\ttfamily{\textquotesingle}b\textquotesingle}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


To be able to give an interpretation an algebra is still required.
Simillarly to the constructors the algebra needs to be modularized.
A type class can be defined that provides the algebra to fold each constructor.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{class}\codeskip \Conid{IFunctor}\codeskip \Varid{iF}\Rightarrow \Conid{SizeAlg}\codeskip \Varid{iF}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{sizeAlg}_{10}\mathbin{::}\Varid{iF}\codeskip \Conid{Size}'\codeskip \Varid{a}\to \Conid{Size}'\codeskip \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip {}\<[13]%
\>[13]{}(\Conid{SizeAlg}\codeskip \Varid{iF},\Conid{SizeAlg}\codeskip \Varid{iG}){}\<[E]%
\\
\>[13]{}\Rightarrow \Conid{SizeAlg}\codeskip (\Varid{iF}:\!\!+\!\!:\Varid{iG})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{sizeAlg}_{10}\codeskip (\Conid{L}\codeskip \Varid{x})\mathrel{=}\Varid{sizeAlg}_{10}\codeskip \Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{sizeAlg}_{10}\codeskip (\Conid{R}\codeskip \Varid{y})\mathrel{=}\Varid{sizeAlg}_{10}\codeskip \Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
One benefit to this approach is that if an interpretation is only needed for parsers that use \ensuremath{\Varid{or}_{10}} and \ensuremath{\Varid{satisfy}_{10}},
then only those instances need to be defined.
Take calculating the size of the parser \ensuremath{\Varid{aorb}_{10}'}, only the two instances need to be defined to do so.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\codeskip \Conid{SizeAlg}\codeskip \Conid{Or}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{sizeAlg}_{10}\codeskip (\Conid{Or}_{10}\codeskip \Varid{px}\codeskip \Varid{py})\mathrel{=}\Varid{px}\mathbin{+}\Varid{py}\mathbin{+}\mathrm{1}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{SizeAlg}\codeskip \Conid{Satisfy}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{sizeAlg}_{10}\codeskip (\Conid{Satisfy}_{10}\codeskip \anonymous )\mathrel{=}\mathrm{1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{size}_{10}\mathbin{::}\Conid{SizeAlg}\codeskip \Varid{iF}\Rightarrow \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}\to \Conid{Size}'\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{size}_{10}\mathrel{=}\Varid{cata}\codeskip \Varid{sizeAlg}_{10}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{eval}\mathbin{::}\Conid{Size}{}\<[E]%
\\
\>[3]{}\Varid{eval}\mathrel{=}\Varid{unSize}\codeskip {}\<[18]%
\>[18]{}(\Varid{size}_{10}\codeskip (\Varid{aorb}_{10}'\mathbin{::}({}\<[E]%
\\
\>[18]{}\Conid{Fix}\codeskip (\Conid{Or}_{10}:\!\!+\!\!:\Conid{Satisfy}_{10}))\codeskip \Conid{Char})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The type of \ensuremath{\Varid{aorb}_{10}'} is required to be specified.
This is so that the compiler knows the top level functor being used and the constructors included in it.
There could possibly an error in the paper here, as it states that only instances for \ensuremath{\Conid{Fan}_{11}} and \ensuremath{\Conid{Stretch}_{11}} need to be defined.
However, it sets the type for \ensuremath{\Varid{stretchfan}} to be \ensuremath{\Conid{Circuit}_{11}}.
This requires that the \ensuremath{\Conid{WidthAlg}_{11}} instances be defined for all constructors in \ensuremath{\Conid{Circuit}_{11}}.
To rectify this type error \ensuremath{\Varid{stretchfan}} should be given the type \ensuremath{\Varid{stretchfan}\mathbin{::}\Conid{Fix}\codeskip (\Conid{Fan}_{11}:\!\!+\!\!:\Conid{Stretch}_{11})}.



\section{Conclusion}
This overview has walked through the techniques described in the paper and applied them to a previously unconsidered case - typed DSLs.
This now allows the techniques in the paper to be taken advantage of in typed DSLs such as parser combinators.
This is done through the use of an \ensuremath{\Conid{IFunctor}} and special instances of \ensuremath{\Conid{Fix}} and \ensuremath{\Varid{cata}}.


\bibliography{biblo}

\appendix
\section{Appendix}


\subsection{Shallow Embedding of \ensuremath{\Varid{size}}}
\label{app:shallow-size}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\codeskip \Conid{Parser}_{3}\codeskip \Varid{a}\mathrel{=}\Conid{Int}{}\<[E]%
\\
\>[3]{}\Varid{pure}_{3}\codeskip {}\<[13]%
\>[13]{}\anonymous {}\<[16]%
\>[16]{}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{satisfy}_{3}\codeskip {}\<[13]%
\>[13]{}\anonymous {}\<[16]%
\>[16]{}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{empty}_{3}{}\<[16]%
\>[16]{}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{try}_{3}\codeskip {}\<[9]%
\>[9]{}\Varid{px}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{px}{}\<[22]%
\>[22]{}\mathbin{+}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{ap}_{3}\codeskip {}\<[9]%
\>[9]{}\Varid{pf}\codeskip \Varid{px}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{pf}{}\<[22]%
\>[22]{}\mathbin{+}\Varid{px}{}\<[28]%
\>[28]{}\mathbin{+}\mathrm{1}{}\<[E]%
\\
\>[3]{}\Varid{or}_{3}\codeskip {}\<[9]%
\>[9]{}\Varid{px}\codeskip \Varid{py}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{px}{}\<[22]%
\>[22]{}\mathbin{+}\Varid{py}{}\<[28]%
\>[28]{}\mathbin{+}\mathrm{1}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{size}_{3}\mathbin{::}\Conid{Parser}_{3}\codeskip \Varid{a}\to \Conid{Size}{}\<[E]%
\\
\>[3]{}\Varid{size}_{3}\mathrel{=}\Varid{id}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\subsection{\ensuremath{\Conid{IFunctor}} instance of \ensuremath{\Conid{ParserF}}}
\label{app:ifunctor-parserf}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Conid{ParserF}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \anonymous \codeskip \Conid{EmptyF}{}\<[26]%
\>[26]{}\mathrel{=}\Conid{EmptyF}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \anonymous \codeskip (\Conid{PureF}\codeskip \Varid{x}){}\<[26]%
\>[26]{}\mathrel{=}\Conid{PureF}\codeskip {}\<[38]%
\>[38]{}\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \anonymous \codeskip (\Conid{SatisfyF}\codeskip \Varid{c}){}\<[26]%
\>[26]{}\mathrel{=}\Conid{SatisfyF}\codeskip {}\<[38]%
\>[38]{}\Varid{c}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \Varid{f}\codeskip (\Conid{TryF}\codeskip \Varid{px}){}\<[26]%
\>[26]{}\mathrel{=}\Conid{TryF}\codeskip {}\<[34]%
\>[34]{}(\Varid{f}\codeskip \Varid{px}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \Varid{f}\codeskip (\Conid{ApF}\codeskip \Varid{pf}\codeskip \Varid{px}){}\<[26]%
\>[26]{}\mathrel{=}\Conid{ApF}\codeskip {}\<[34]%
\>[34]{}(\Varid{f}\codeskip \Varid{pf})\codeskip {}\<[42]%
\>[42]{}(\Varid{f}\codeskip \Varid{px}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \Varid{f}\codeskip (\Conid{OrF}\codeskip \Varid{px}\codeskip \Varid{py}){}\<[26]%
\>[26]{}\mathrel{=}\Conid{OrF}\codeskip {}\<[34]%
\>[34]{}(\Varid{f}\codeskip \Varid{px})\codeskip {}\<[42]%
\>[42]{}(\Varid{f}\codeskip \Varid{py}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Constructors for a Parameterized Shallow Embedding}
\label{app:parser7-constructors}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{empty}_{7}\mathbin{::}\Conid{Parser}_{7}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{empty}_{7}\mathrel{=}\Conid{P}_{7}\codeskip (\lambda \Varid{h}\to \Varid{h}\codeskip \Conid{EmptyF}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{pure}_{7}\mathbin{::}\Varid{a}\to \Conid{Parser}_{7}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{pure}_{7}\codeskip \Varid{x}\mathrel{=}\Conid{P}_{7}\codeskip (\lambda \Varid{h}\to \Varid{h}\codeskip (\Conid{PureF}\codeskip \Varid{x})){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{try}_{7}\mathbin{::}\Conid{Parser}_{7}\codeskip \Varid{a}\to \Conid{Parser}_{7}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{try}_{7}\codeskip \Varid{px}\mathrel{=}\Conid{P}_{7}\codeskip (\lambda \Varid{h}\to \Varid{h}\codeskip (\Conid{TryF}\codeskip (\Varid{unP}_{7}\codeskip \Varid{px}\codeskip \Varid{h}))){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{ap}_{7}\mathbin{::}\Conid{Parser}_{7}\codeskip (\Varid{a}\to \Varid{b})\to \Conid{Parser}_{7}\codeskip \Varid{a}\to \Conid{Parser}_{7}\codeskip \Varid{b}{}\<[E]%
\\
\>[3]{}\Varid{ap}_{7}\codeskip \Varid{pf}\codeskip \Varid{px}\mathrel{=}\Conid{P}_{7}\codeskip (\lambda \Varid{h}\to \Varid{h}\codeskip (\Conid{ApF}\codeskip (\Varid{unP}_{7}\codeskip \Varid{pf}\codeskip \Varid{h})\codeskip (\Varid{unP}_{7}\codeskip \Varid{px}\codeskip \Varid{h}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Converting from Deep to a Parameterized Shallow Embedding}
\label{app:shallowalg}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{shallowAlg}\mathbin{::}\Conid{ParserAlg}\codeskip \Conid{Parser}_{7}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{shallowAlg}\codeskip \Conid{EmptyF}{}\<[28]%
\>[28]{}\mathrel{=}\Varid{empty}_{7}{}\<[E]%
\\
\>[3]{}\Varid{shallowAlg}\codeskip (\Conid{PureF}\codeskip \Varid{x}){}\<[28]%
\>[28]{}\mathrel{=}\Varid{pure}_{7}\codeskip \Varid{x}{}\<[E]%
\\
\>[3]{}\Varid{shallowAlg}\codeskip (\Conid{SatisfyF}\codeskip \Varid{c}){}\<[28]%
\>[28]{}\mathrel{=}\Varid{satisfy}_{7}\codeskip \Varid{c}{}\<[E]%
\\
\>[3]{}\Varid{shallowAlg}\codeskip (\Conid{TryF}\codeskip \Varid{px}){}\<[28]%
\>[28]{}\mathrel{=}\Varid{try}_{7}\codeskip \Varid{px}{}\<[E]%
\\
\>[3]{}\Varid{shallowAlg}\codeskip (\Conid{ApF}\codeskip \Varid{pf}\codeskip \Varid{px}){}\<[28]%
\>[28]{}\mathrel{=}\Varid{ap}_{7}\codeskip \Varid{pf}\codeskip \Varid{px}{}\<[E]%
\\
\>[3]{}\Varid{shallowAlg}\codeskip (\Conid{OrF}\codeskip \Varid{px}\codeskip \Varid{py}){}\<[28]%
\>[28]{}\mathrel{=}\Varid{or}_{7}\codeskip \Varid{px}\codeskip \Varid{py}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Datatypes and IFunctor Instances for a Modular Interpretation}
\label{app:modular-dtypes-ifunctors}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\codeskip \Conid{Empty}_{10}\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Empty}_{10}\mathbin{::}\Conid{Empty}_{10}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\codeskip \Conid{Pure}_{10}\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Pure}_{10}\mathbin{::}\Varid{a}\to \Conid{Pure}_{10}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\codeskip \Conid{Satisfy}_{10}\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Satisfy}_{10}\mathbin{::}(\Conid{Char}\to \Conid{Bool})\to \Conid{Satisfy}_{10}\codeskip \Varid{f}\codeskip \Conid{Char}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\codeskip \Conid{Try}_{10}\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Try}_{10}\mathbin{::}\Varid{f}\codeskip \Varid{a}\to \Conid{Try}_{10}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\codeskip \Conid{Or}_{10}\codeskip (\Varid{f}\mathbin{::}\mathbin{*}\to \mathbin{*})\codeskip (\Varid{a}\mathbin{::}\mathbin{*})\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Or}_{10}\mathbin{::}\Varid{f}\codeskip \Varid{a}\to \Varid{f}\codeskip \Varid{a}\to \Conid{Or}_{10}\codeskip \Varid{f}\codeskip \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Conid{Empty}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \anonymous \codeskip \Conid{Empty}_{10}\mathrel{=}\Conid{Empty}_{10}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Conid{Pure}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \anonymous \codeskip (\Conid{Pure}_{10}\codeskip \Varid{x})\mathrel{=}\Conid{Pure}_{10}\codeskip \Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Conid{Satisfy}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \anonymous \codeskip (\Conid{Satisfy}_{10}\codeskip \Varid{c})\mathrel{=}\Conid{Satisfy}_{10}\codeskip \Varid{c}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Conid{Try}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \Varid{f}\codeskip (\Conid{Try}_{10}\codeskip \Varid{px})\mathrel{=}\Conid{Try}_{10}\mathbin{\$}\Varid{f}\codeskip \Varid{px}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{instance}\codeskip \Conid{IFunctor}\codeskip \Conid{Or}_{10}\codeskip \mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{imap}\codeskip \Varid{f}\codeskip (\Conid{Or}_{10}\codeskip \Varid{px}\codeskip \Varid{py})\mathrel{=}\Conid{Or}_{10}\codeskip (\Varid{f}\codeskip \Varid{px})\codeskip (\Varid{f}\codeskip \Varid{py}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\subsection{Smart Constructors to Inject \ensuremath{\Conid{L}} and \ensuremath{\Conid{R}}'s}
\label{app:modular-smart-constructors}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{empty}_{10}\mathbin{::}(\Conid{Empty}_{10}:\prec:\Varid{iF})\Rightarrow \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{empty}_{10}\mathrel{=}\Conid{In}\codeskip (\Varid{inj}\codeskip \Conid{Empty}_{10}){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{pure}_{10}\mathbin{::}(\Conid{Pure}_{10}:\prec:\Varid{iF})\Rightarrow \Varid{a}\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{pure}_{10}\codeskip \Varid{x}\mathrel{=}\Conid{In}\codeskip (\Varid{inj}\codeskip (\Conid{Pure}_{10}\codeskip \Varid{x})){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{try}_{10}\mathbin{::}(\Conid{Try}_{10}:\prec:\Varid{iF})\Rightarrow \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}{}\<[E]%
\\
\>[3]{}\Varid{try}_{10}\codeskip \Varid{px}\mathrel{=}\Conid{In}\codeskip (\Varid{inj}\codeskip (\Conid{Try}_{10}\codeskip \Varid{px})){}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{ap}_{10}\mathbin{::}(\Conid{Ap}_{10}:\prec:\Varid{iF})\Rightarrow \Conid{Fix}\codeskip \Varid{iF}\codeskip (\Varid{a}\to \Varid{b})\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{a}\to \Conid{Fix}\codeskip \Varid{iF}\codeskip \Varid{b}{}\<[E]%
\\
\>[3]{}\Varid{ap}_{10}\codeskip \Varid{pf}\codeskip \Varid{px}\mathrel{=}\Conid{In}\codeskip (\Varid{inj}\codeskip (\Conid{Ap}_{10}\codeskip \Varid{pf}\codeskip \Varid{px})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks




\end{document}
